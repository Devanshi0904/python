MODULE – 7 :  
 

Que - 1. Accessing List

1. Understanding how to create and access elements in a list.
-  Creating a list:
• fruits = ["apple", "banana", "cherry"]

-  Accessing elements in a list: 
• Use square brackets [] with the index of the item. 
Print (fruits [0]) # Output: apple
print (fruits [1]) # Output: banana 
print (fruits [2]) # Output: cherry
       

2. Indexing in lists (positive and negative indexing).
- Positive indexing: Starts from 0 at the beginning of the list.
• Example :
 	num = [10, 20, 30, 40]
    print(num[0])  
    print(num[2])  

- Negative indexing: Starts from -1 at the end of the list.
• Example :
nums = [10, 20, 30, 40]
print(nums[-1])  
print(nums[-2])  


3. Slicing a list: accessing a range of elements.
- Syntax: list[start:stop] 

• Includes elements from start to stop - 1. 
- Example: 
fruits = ["apple", "banana", "cherry", "date", "elderberry"]

 # Slice from index
 print(fruits[1:4]) # ['banana', 'cherry', 'date'] 

#Start or end to slice from/to beginning or end 
print(fruits[:3]) # ['apple', 'banana', 'cherry']
print(fruits[2:]) # ['cherry', 'date', 'elderberry'] 

# Slicing with negative indexes 
print(fruits[-4:-1]) # ['banana', 'cherry', 'date']



Que – 2 List Operations 

1. Common list operations: concatenation, repetition, membership.

• Concatenation (+)  :   # joins lists.
[1,2] + [3,4]  # [1,2,3,4]
• Repetition (*)  :  # repeats list.
[1,2] * 3  # [1,2,1,2,1,2]

• Membership (in, not in)  :  # checks if element exists.
2 in [1,2,3]     # True
4 not in [1,2,3] # True


2. Understanding list methods like append(), insert(), remove(), pop().
• append(item) :
- Adds an element to the end of the list.
nums = [1, 2, 3]
nums.append(4)
print(nums)  # [1, 2, 3, 4]

• insert(index, item) :
- Adds an element at a specific position.
nums = [1, 2, 3]
nums.insert(1, 10)   # insert 10 at index 1
print(nums)  # [1, 10, 2, 3]

• remove(item) :
- Removes the first occurrence of a value.
nums = [1, 2, 3, 2]
nums.remove(2)
print(nums)  # [1, 3, 2]

• pop(index) :
- Removes and returns an element.
o If index is given → removes that element.
o If no index → removes the last element.
nums = [1, 2, 3]
x = nums.pop(1)  # removes element at index 1
print(x)     # 2
print(nums)  # [1, 3]

y = nums.pop()   # removes last element
print(y)     # 3
print(nums)  # [1]



Que – 3  Working with Lists

1. Iterating over a list using loops.
i. Using for loop: 
fruits = ["apple", "banana", "cherry"] 
for fruit in fruits:
 print(fruit) 

ii. Using for loop with index (range)
 for i in range(len(fruits)): 
print(f"{i}: {fruits[i]}") 
iii. Using while loop:
 i = 0
 while i < len(fruits): 
print(fruits[i]) i += 1


2. Sorting and reversing a list using sort(), sorted(), and reverse().

i. sort() — Sorts the list in place. Modifies the original list.
 list = [4, 2, 7, 1] list.sort()
 print(list) # [1, 2, 4, 7] 

ii.  sorted() — Returns a new sorted list and the original list remains unchanged. 
list = [4, 2, 7, 1] sorted_list = sorted(list) 
print(sorted_list)    # [1, 2, 4, 7]
print(list)     # [4, 2, 7, 1]

iii. reverse() — reverses the list in place
 fruits = ["apple", "banana", "cherry"] 
fruits.reverse() 
print(fruits)         # ['cherry', 'banana', 'apple']

iv. Reverse using slicing:
reversed_list = fruits[::-1] 
print(reversed_list)      # ['apple', 'banana', 'cherry']


3. Basic list manipulations: addition, deletion, updating, and slicing.
• Addition :
- numbers = [10, 20, 30, 40, 50]

numbers.append(60)           # Add single element at end → [10, 20, 30, 40, 50, 60]
numbers.insert(2, 25)          # Insert at index 2 → [10, 20, 25, 30, 40, 50, 60]
numbers.extend([70, 80])   # Add multiple elements → [10, 20, 25, 30, 40, 50, 60, 70, 80]

• Deletion :
- numbers = [10, 20, 30, 40, 50]

numbers.remove(25)        # Remove value → [10, 20, 30, 40, 50, 60, 70, 80]
numbers.pop(3)                 # Remove by index (index 3 → 40) → [10, 20, 30, 50, 60, 70, 80]
del numbers[0]                  # Delete first element → [20, 30, 50, 60, 70, 80]
numbers.clear()                 # Empty list → []

• Updating :
- nums = [1, 2, 3, 4, 5]

nums[2] = 10                   # Update index 2 → [1, 2, 10, 4, 5]
nums[1:3] = [20, 30]      # Update a slice → [1, 20, 30, 4, 5]

• Slicing :
- mylist = [100, 200, 300, 400, 500]

print(mylist[1:4])         # [200, 300, 400] (from index 1 to 3)
print(mylist[:3])           # [100, 200, 300] (start to index 2)
- print(mylist[2:])         # [300, 400, 500] (from index 2 to end)
- print(mylist[::-1])       # [500, 400, 300, 200, 100] (reversed)


Que – 4  Tuple
1. Introduction to tuples, immutability.
• What is a tuple? 
- A tuple is an ordered collection of items, just like a list.
-  Unlike lists, tuples cannot be changed (immutable). 

• Why use tuples? 
-  They're faster than lists. 
-  They're useful for fixed data (e.g., coordinates, RGB values). 
-  They're hashable and can be used as dictionary keys.
 my_tuple = (1, 2, 2, 3) 
print(my_tuple) #(1,2,2,3) 

• Immutability using example
 my_tuple = (10, 20, 30)
 # my_tuple[0] = 100           # This will raise a TypeError


2. Creating and accessing elements in a tuple.       
i. Creating tuples:
 t1 = (1, 2, 3)
 t2 = ("apple", "banana", "cherry")
 t3 = ()       # Empty tuple
 t4 = (5,)     # Single-element tuple (comma is required!) 

ii. Accessing tuple elements:
-  It is same as lists using indexing and slicing.
colors = ("red", "green", "blue") 
print(colors[0])        # red
print(colors[-1])      # blue
print(colors[1:3])    # ('green', 'blue')


3. Basic operations with tuples: concatenation, repetition, membership.
• Concatenation (+):
t1 = (1, 2, 3)
t2 = (4, 5)
result = t1 + t2   # (1, 2, 3, 4, 5)

• Repetition (*) :
t = (1, 2)
result = t * 3     # (1, 2, 1, 2, 1, 2)

• Membership (in, not in):
t = (10, 20, 30)
print(20 in t)     # True
print(40 not in t) # True



Que – 5  Accessing Tuples
1. Accessing tuple elements using positive and negative indexing.
• Positive Indexing :
- Starts from 0 for the first element.
- Increases by 1 as you move forward.

o Example:
my_tuple = ("apple", "banana", "cherry", "date")

print(my_tuple[0])        # "apple"  (first element)
print(my_tuple[1])        # "banana" (second element)
print(my_tuple[2])        # "cherry"

• Negative Indexing
- Starts from -1 for the last element.
- Moves backward as the index decreases.

o Example:
my_tuple = ("apple", "banana", "cherry", "date")

print(my_tuple[-1])             # "date"   (last element)
print(my_tuple[-2])             # "cherry" (second last element)
print(my_tuple[-3])             # "banana"


2. Slicing a tuple to access ranges of elements.
- Syntax: tuple[start:stop:step] 
- Returns a new tuple from start to stop - 1.

o Example: 

colors = ("red", "green", "blue", "yellow", "purple") 
# Slice from index 1 to 3
 print(colors[1:4]) # ('green', 'blue', 'yellow') 
# Slice from start to index 2 
print(colors[:3]) # ('red', 'green', 'blue')
 # Slice from index 2 to end 
print(colors[2:]) # ('blue', 'yellow', 'purple')
 # Slice with step 
print(colors[::2]) # ('red', 'blue', 'purple') 
# Reverse the tuple
 print(colors[::-1]) # ('purple', 'yellow', 'blue', 'green', 'red')



Que – 6  Dictionaries

1. Introduction to dictionaries: key-value pairs.
• What is a dictionary?
- A dictionary is an unordered, mutable collection of items. Each item is stored as a key-value pair. 
- Keys must be unique and immutable (like strings, numbers, or tuples).
-  Values can be of any data type.


• Syntax: my_dict = { "name": "devanshi",
                     "age": 20,
                    "city": "surat"
                    }


2. Accessing, adding, updating, and deleting dictionary elements.
i.  Accessing values :
print(d["name"])     # devanshi
# using get() method 
print(d.get("age")) # 20

 ii. Adding a new key-value pair :
 d["email"] = devanshi@gmail.com 
print (d)

 iii. Updating a value :
 my_dict["age"] = 26 

iv. Deleting an item :
 del  d ["city"]             # Removes the key 'city'
d.pop("age")              # Also removes and returns value of 'age'
d.clear()                      # Removes all items from the dictionary



3. Dictionary methods like keys(), values(), and items().
• d.keys()  : returns a view object containing all the keys of the dictionary.
d = {"a": 1, "b": 2}
print(d.keys())           # d(['a', 'b'])

• dict.values() → returns a view object containing all the values.
print(d.values())        # d ([1, 2])

• dict.items() → returns a view object of key-value pairs as tuples.
print(d.items())         # d([('a', 1), ('b', 2)])



Que – 7  Working with Dictionaries
1. Iterating over a dictionary using loops.
- You can iterate a dictionary through:
 • Keys
 • Values 
• Key-value pairs 

i. Iterating over keys (default)  :
person = {"name": "devanshi", "age": 20, "city": "surat"} 
for key in person: 
print(key, "->", person[key])

ii. Iterating over .items() (key-value pairs) :
 for key, value in person.items():
 print(f"{key}: {value}")
iii. Iterating over values :
for value in person.values():
 print(value) 



2. Merging two lists into a dictionary using loops or zip().
• Using zip():
keys = ["a", "b", "c"]
values = [1, 2, 3]

result = dict(zip(keys, values))
print(result)          # {'a': 1, 'b': 2, 'c': 3}


• Using loop:
result = {}
for i in range(len(keys)):
 result[keys[i]] = values[i]

print(result)  # {'a': 1, 'b': 2, 'c': 3}



3. Counting occurrences of characters in a string using dictionaries.
- To count how often each character appears in a string, use a dictionary. 
text = "hello world" 
char_count = {} 
for char in text:
     if char in char_count: 
          char_count[char] += 1
     else: 
          char_count[char] = 1 
print(char_count)                                # {'h': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, 'w': 1, 'r': 1, 'd': 1}



 
Que – 8   Functions
1. Defining functions in Python.
-  A function is a reusable block of code that can performs a specific task. 
• Syntax:
def greet(): 
        print("Hello!")
 #Calling the function: 
greet()


2. Different types of functions: with/without parameters, with/without return values.
•  Without parameters, without return value
def greet():
    print("Hello!")
greet()

• Without parameters, with return value
def get_pi():
    return 3.14
print(get_pi())

• With parameters, without return value
def greet_user(name):
   print(f"Hello, {name}!")
greet_user("Alice")

• With parameters, with return value
def add(a, b):
   return a + b
print(add(5, 3))


3. Anonymous functions (lambda functions).
- Lambda functions are small, one-line anonymous functions. 
• Syntax: lambda arguments: expression. 
-  Use them when a short function is needed for a short time (e.g. with map(), filter(), or sorted()). 

•  Example: 
add = lambda x, y: x + y 
print(add(3, 4))       # Output: 7




Que – 9  Modules
1. Introduction to Python modules and importing modules.
-  A module is a file containing Python code (functions, variables, classes).
i. Importing a module:
-  import math
-  import random 

ii. Importing a specific item: 
- from math import sqrt 


2. Standard library modules: math, random.
- math → Provides mathematical functions (e.g., sqrt(), sin(), cos(), log(), constants like pi, e).

• Example:
import math
print(math.sqrt(16))   # 4.0
print(math.pi)         # 3.141592653589793
-  random → Provides random number generation and choices.
• Example:
import random
print(random.randint(1, 10))           # random integer between 1 and 10
print(random.choice(['a', 'b']))        # random element from list





3. Creating custom modules.
- You can create your own module by saving a .py file with functions. Ie. Here math_utils.py. 
- Then use it in another file.
- Make sure both files are in the same directory or properly configured in your project. 

• Example: 
def add(a, b): 
return a + b 

def multiply(a, b): 
     return a * b 
import math_utils 
print(math_utils.add(2, 3)) # 5 
print(math_utils.multiply(4, 5)) # 20.

